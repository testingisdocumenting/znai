<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Text Highlighter Demo</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 900px;
            margin: 40px auto;
            padding: 20px;
            line-height: 1.6;
        }

        .demo-container {
            border: 2px solid #ddd;
            padding: 20px;
            margin: 20px 0;
            background: #f9f9f9;
        }

        .highlight {
            background-color: #ffeb3b;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .highlight.clicked {
            background-color: #ff9800;
        }

        .highlight-start {
            border-radius: 4px 0 0 4px;
            padding-left: 2px;
        }

        .highlight-end {
            border-radius: 0 4px 4px 0;
            padding-right: 2px;
        }

        .highlight-middle {
            border-radius: 0;
        }

        .highlight-single {
            border-radius: 4px;
            padding: 0 2px;
        }

        .controls {
            margin-bottom: 20px;
            padding: 15px;
            background: #e8e8e8;
            border-radius: 5px;
        }

        .control-group {
            margin-bottom: 10px;
        }

        .control-group label {
            display: inline-block;
            width: 100px;
            font-weight: bold;
        }

        input[type="text"] {
            padding: 8px;
            width: 300px;
            margin-right: 10px;
        }

        button {
            padding: 8px 15px;
            background: #2196F3;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-right: 10px;
        }

        button:hover {
            background: #1976D2;
        }

        button.example-btn {
            background: #4CAF50;
            font-size: 12px;
            padding: 5px 10px;
        }

        button.example-btn:hover {
            background: #45a049;
        }

        button.use-selection {
            background: #9C27B0;
        }

        button.use-selection:hover {
            background: #7B1FA2;
        }

        ::selection {
            background: #B39DDB;
            color: #000;
        }

        code {
            background: #f4f4f4;
            padding: 2px 4px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
        }

        pre {
            background: #f8f8f8;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 15px;
            overflow-x: auto;
            margin: 15px 0;
        }

        pre code {
            background: none;
            padding: 0;
            display: block;
            line-height: 1.5;
        }

        .info {
            background: #e3f2fd;
            padding: 10px;
            margin: 10px 0;
            border-radius: 4px;
            font-size: 14px;
        }
    </style>
</head>
<body>
<h1>Text Highlighter with Prefix/Suffix Context</h1>

<div class="controls">
    <div class="control-group">
        <label>Search Text:</label>
        <input type="text" id="searchText" placeholder="Enter text to highlight" value="multiple">
        <span style="font-size: 12px; color: #666; margin-left: 10px;">Use \n for newlines</span>
    </div>
    <div class="control-group">
        <label>Prefix:</label>
        <input type="text" id="prefixText" placeholder="Text before (optional)" value="">
        <button class="example-btn" onclick="setExample1()">Example 1</button>
        <button class="example-btn" onclick="setExample3()">Code Example</button>
    </div>
    <div class="control-group">
        <label>Suffix:</label>
        <input type="text" id="suffixText" placeholder="Text after (optional)" value="">
        <button class="example-btn" onclick="setExample2()">Example 2</button>
        <button class="example-btn" onclick="setExample4()">HTML Example</button>
    </div>
    <div style="margin-top: 15px;">
        <button onclick="highlightText()">Highlight</button>
        <button onclick="clearHighlights()">Clear Highlights</button>
        <button onclick="useSelection()" class="use-selection">Use Selection</button>
    </div>
</div>

<div class="info" id="clickInfo">Select any text and click "Use Selection" to auto-generate unique prefix/suffix context!</div>

<div class="demo-container" id="content">
    <h2>Sample Content with Multiple Occurrences</h2>
    <p>This is a <strong>paragraph</strong> with <em>various</em> inline elements. The text <span style="color: blue;">spans</span> across multiple <code>DOM nodes</code> and elements.</p>

    <div>This content is <span>nested deeply</span> and the highlighter <span>can handle text that <strong>spans across multiple</strong> levels</span> of nesting.</div>

    <p>Here's another paragraph with the word multiple appearing several times. We can use prefix/suffix to target specific occurrences of multiple words.</p>

    <h3>Code Examples</h3>
    <p>The highlighter also works with inline code like <code>const multiple = items.filter()</code> and can highlight text within code blocks:</p>

    <pre><code>// JavaScript example with multiple occurrences
function processMultipleItems(items) {
    // Handle multiple selections
    const multiple = items.filter(item => item.selected);

    // Process multiple times if needed
    for (let i = 0; i < multiple.length; i++) {
        console.log(`Processing item ${i} of multiple items`);
    }

    return multiple;
}</code></pre>

    <ul>
        <li>List items can also <span>contain text that spans</span> across multiple nodes</li>
        <li>The highlighter works with <code>multiple HTML structures</code></li>
        <li>You can disambiguate between multiple instances of the same text</li>
    </ul>

    <p>The word multiple appears many times in this demo. Use prefix and suffix to highlight only specific instances!</p>
</div>

<script>
    // Text Highlighter Class
    class TextHighlighter {
        constructor(container) {
            this.container = container;
            this.highlights = [];
        }

        getTextNodes(node) {
            const textNodes = [];
            const walker = document.createTreeWalker(
                node,
                NodeFilter.SHOW_TEXT,
                null,
                false
            );

            let textNode;
            while (textNode = walker.nextNode()) {
                textNodes.push(textNode);
            }
            return textNodes;
        }

        findMatches(searchText, prefix, suffix) {
            if (!searchText) return [];

            prefix = prefix || '';
            suffix = suffix || '';

            const textNodes = this.getTextNodes(this.container);
            const matches = [];

            // Build node map
            let currentPos = 0;
            const nodeMap = textNodes.map(node => {
                const start = currentPos;
                const end = currentPos + node.nodeValue.length;
                currentPos = end;
                return { node, start, end, text: node.nodeValue };
            });

            const fullText = nodeMap.map(item => item.text).join('');

            // Build pattern
            let pattern = '';
            if (prefix) {
                pattern += '(' + this.escapeRegex(prefix) + ')\\s*';
            }
            pattern += '(' + this.escapeRegex(searchText) + ')';
            if (suffix) {
                pattern += '\\s*(' + this.escapeRegex(suffix) + ')';
            }

            try {
                const regex = new RegExp(pattern, 'is'); // Only need first match since it should be unique
                const match = regex.exec(fullText);

                if (match) {
                    let searchGroupIndex = prefix ? 2 : 1;
                    let matchStart = match.index;

                    if (prefix || suffix) {
                        let groupStart = 0;
                        for (let i = 1; i < searchGroupIndex; i++) {
                            groupStart += match[i] ? match[i].length : 0;
                        }
                        matchStart = match.index + groupStart;
                    }

                    const matchEnd = matchStart + match[searchGroupIndex].length;

                    const affectedNodes = [];
                    nodeMap.forEach(nodeInfo => {
                        if (nodeInfo.end > matchStart && nodeInfo.start < matchEnd) {
                            affectedNodes.push({
                                node: nodeInfo.node,
                                start: Math.max(0, matchStart - nodeInfo.start),
                                end: Math.min(nodeInfo.text.length, matchEnd - nodeInfo.start),
                                text: nodeInfo.text
                            });
                        }
                    });

                    if (affectedNodes.length > 0) {
                        matches.push({
                            nodes: affectedNodes,
                            fullMatch: match[0],
                            searchMatch: match[searchGroupIndex]
                        });
                    }
                }
            } catch (e) {
                console.error('Regex error:', e);
            }

            return matches;
        }

        escapeRegex(str) {
            str = str.replace(/\\n/g, '\n');
            str = str.replace(/\\s/g, '\\s');
            return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        }

        highlight(searchText, prefix, suffix, onClick) {
            this.clearHighlights();

            const matches = this.findMatches(searchText, prefix, suffix);

            matches.forEach((match, matchIndex) => {
                const highlightGroup = [];

                const handleMouseEnter = () => {
                    highlightGroup.forEach(span => {
                        span.style.backgroundColor = '#fdd835';
                    });
                };

                const handleMouseLeave = () => {
                    highlightGroup.forEach(span => {
                        span.style.backgroundColor = '';
                    });
                };

                const handleClick = (e) => {
                    e.stopPropagation();
                    highlightGroup.forEach(span => {
                        span.classList.add('clicked');
                        setTimeout(() => span.classList.remove('clicked'), 500);
                    });

                    if (onClick) {
                        onClick(e, {
                            matchIndex,
                            text: searchText,
                            prefix,
                            suffix,
                            fullMatch: match.fullMatch,
                            searchMatch: match.searchMatch
                        });
                    }
                };

                match.nodes.forEach((nodeInfo, nodeIndex) => {
                    const parent = nodeInfo.node.parentNode;
                    if (!parent) return;

                    const beforeText = nodeInfo.node.nodeValue.substring(0, nodeInfo.start);
                    const highlightText = nodeInfo.node.nodeValue.substring(nodeInfo.start, nodeInfo.end);
                    const afterText = nodeInfo.node.nodeValue.substring(nodeInfo.end);

                    const highlightSpan = document.createElement('span');
                    highlightSpan.className = 'highlight';
                    highlightSpan.textContent = highlightText;

                    if (match.nodes.length === 1) {
                        highlightSpan.classList.add('highlight-single');
                    } else if (nodeIndex === 0) {
                        highlightSpan.classList.add('highlight-start');
                    } else if (nodeIndex === match.nodes.length - 1) {
                        highlightSpan.classList.add('highlight-end');
                    } else {
                        highlightSpan.classList.add('highlight-middle');
                    }

                    const fragment = document.createDocumentFragment();
                    if (beforeText) fragment.appendChild(document.createTextNode(beforeText));
                    fragment.appendChild(highlightSpan);
                    if (afterText) fragment.appendChild(document.createTextNode(afterText));

                    parent.replaceChild(fragment, nodeInfo.node);
                    highlightGroup.push(highlightSpan);
                });

                highlightGroup.forEach(span => {
                    span.addEventListener('mouseenter', handleMouseEnter);
                    span.addEventListener('mouseleave', handleMouseLeave);
                    span.addEventListener('click', handleClick);
                });

                this.highlights.push(highlightGroup);
            });

            return this.highlights.length;
        }

        clearHighlights() {
            this.highlights.forEach(group => {
                group.forEach(span => {
                    const parent = span.parentNode;
                    if (parent) {
                        parent.replaceChild(document.createTextNode(span.textContent), span);
                    }
                });
            });
            this.container.normalize();
            this.highlights = [];
        }
    }

    // Global variables
    let highlighter = null;

    // Functions
    function highlightText() {
        if (!highlighter) return;

        const searchText = document.getElementById('searchText').value;
        const prefixText = document.getElementById('prefixText').value;
        const suffixText = document.getElementById('suffixText').value;

        const count = highlighter.highlight(searchText, prefixText, suffixText, (event, info) => {
            document.getElementById('clickInfo').textContent =
                `Clicked: "${info.searchMatch}" (Match #${info.matchIndex + 1})`;
        });

        const infoEl = document.getElementById('clickInfo');
        if (count === 0 && searchText) {
            infoEl.textContent = 'No matches found!';
        } else if (count > 0) {
            infoEl.textContent = 'Found and highlighted the match. Click on the highlighted text!';
        }
    }

    function clearHighlights() {
        if (!highlighter) return;
        highlighter.clearHighlights();
        document.getElementById('clickInfo').textContent =
            'Select any text and click "Use Selection" to auto-generate unique prefix/suffix context!';
    }

    function setExample1() {
        document.getElementById('searchText').value = 'multiple';
        document.getElementById('prefixText').value = 'across';
        document.getElementById('suffixText').value = 'levels';
        highlightText();
    }

    function setExample2() {
        document.getElementById('searchText').value = 'multiple';
        document.getElementById('prefixText').value = 'between';
        document.getElementById('suffixText').value = 'instances';
        highlightText();
    }

    function setExample3() {
        document.getElementById('searchText').value = 'multiple';
        document.getElementById('prefixText').value = 'const';
        document.getElementById('suffixText').value = '= items';
        highlightText();
    }

    function setExample4() {
        document.getElementById('searchText').value = 'multiple';
        document.getElementById('prefixText').value = 'with';
        document.getElementById('suffixText').value = 'HTML';
        highlightText();
    }

    function useSelection() {
        const selection = window.getSelection();
        if (!selection.rangeCount) {
            document.getElementById('clickInfo').textContent = 'Please select some text first!';
            return;
        }

        const selectedText = selection.toString().trim();
        if (!selectedText) {
            document.getElementById('clickInfo').textContent = 'Please select some text first!';
            return;
        }

        const range = selection.getRangeAt(0);
        const container = document.getElementById('content');

        // Find the nearest heading element
        function findNearestHeading() {
            let currentElement = range.startContainer;
            if (currentElement.nodeType === Node.TEXT_NODE) {
                currentElement = currentElement.parentElement;
            }

            // Walk up the DOM tree and through previous siblings to find headings
            let closestHeading = null;
            let element = currentElement;

            while (element && element !== container) {
                // Check current element and all previous siblings
                let sibling = element;
                while (sibling) {
                    // Check if it's a heading
                    if (/^H[1-4]$/i.test(sibling.tagName)) {
                        closestHeading = sibling;
                        break;
                    }

                    // Check children of previous siblings for headings
                    const headingInSibling = sibling.querySelector('h1, h2, h3, h4');
                    if (headingInSibling) {
                        // Find the last heading in this sibling
                        const allHeadings = sibling.querySelectorAll('h1, h2, h3, h4');
                        closestHeading = allHeadings[allHeadings.length - 1];
                    }

                    sibling = sibling.previousElementSibling;
                }

                if (closestHeading) break;
                element = element.parentElement;
            }

            // If no heading found above, check the entire container for any heading
            if (!closestHeading) {
                const allHeadings = container.querySelectorAll('h1, h2, h3, h4');
                if (allHeadings.length > 0) {
                    // Find the heading that appears before our selection
                    for (let i = allHeadings.length - 1; i >= 0; i--) {
                        const heading = allHeadings[i];
                        const headingPos = heading.compareDocumentPosition(range.startContainer);
                        if (headingPos & Node.DOCUMENT_POSITION_FOLLOWING) {
                            closestHeading = heading;
                            break;
                        }
                    }
                    // If no heading before selection, use the first one
                    if (!closestHeading) {
                        closestHeading = allHeadings[0];
                    }
                }
            }

            return closestHeading ? {
                tag: closestHeading.tagName.toLowerCase(),
                text: closestHeading.textContent.trim()
            } : null;
        }

        const nearestHeading = findNearestHeading();
        console.log('Nearest heading:', nearestHeading);

        // Get the actual selected range's context by expanding it
        function getExpandedContext(charsBefore, charsAfter) {
            const expandedRange = range.cloneRange();

            // Expand backwards
            try {
                let moved = 0;
                let currentContainer = expandedRange.startContainer;
                let currentOffset = expandedRange.startOffset;

                while (moved < charsBefore) {
                    if (currentContainer.nodeType === Node.TEXT_NODE) {
                        const availableChars = currentOffset;
                        const toMove = Math.min(charsBefore - moved, availableChars);
                        expandedRange.setStart(currentContainer, currentOffset - toMove);
                        moved += toMove;
                        if (moved >= charsBefore) break;

                        // Need to move to previous text node
                        const prev = getPreviousTextNode(currentContainer, container);
                        if (!prev) break;
                        currentContainer = prev;
                        currentOffset = prev.textContent.length;
                    } else {
                        break;
                    }
                }
            } catch (e) {
                console.log('Error expanding backwards:', e);
            }

            // Expand forwards
            try {
                let moved = 0;
                let currentContainer = expandedRange.endContainer;
                let currentOffset = expandedRange.endOffset;

                while (moved < charsAfter) {
                    if (currentContainer.nodeType === Node.TEXT_NODE) {
                        const availableChars = currentContainer.textContent.length - currentOffset;
                        const toMove = Math.min(charsAfter - moved, availableChars);
                        expandedRange.setEnd(currentContainer, currentOffset + toMove);
                        moved += toMove;
                        if (moved >= charsAfter) break;

                        // Need to move to next text node
                        const next = getNextTextNode(currentContainer, container);
                        if (!next) break;
                        currentContainer = next;
                        currentOffset = 0;
                    } else {
                        break;
                    }
                }
            } catch (e) {
                console.log('Error expanding forwards:', e);
            }

            return expandedRange.toString();
        }

        function getPreviousTextNode(node, root) {
            const walker = document.createTreeWalker(
                root,
                NodeFilter.SHOW_TEXT,
                null,
                false
            );

            let current;
            let previous = null;
            while (current = walker.nextNode()) {
                if (current === node) {
                    return previous;
                }
                previous = current;
            }
            return null;
        }

        function getNextTextNode(node, root) {
            const walker = document.createTreeWalker(
                root,
                NodeFilter.SHOW_TEXT,
                null,
                false
            );

            let current;
            let found = false;
            while (current = walker.nextNode()) {
                if (found) {
                    return current;
                }
                if (current === node) {
                    found = true;
                }
            }
            return null;
        }

        // Get a large context around the selection to identify it uniquely
        const largeContext = getExpandedContext(100, 100);
        const selectionStartInContext = largeContext.indexOf(selectedText);

        if (selectionStartInContext === -1) {
            document.getElementById('clickInfo').textContent = 'Error: Could not find selection in context';
            return;
        }

        // Extract the actual prefix and suffix from the large context
        const actualPrefix = largeContext.substring(0, selectionStartInContext);
        const actualSuffix = largeContext.substring(selectionStartInContext + selectedText.length);

        console.log('Actual context around selection:');
        console.log('Prefix (last 50 chars):', actualPrefix.slice(-50));
        console.log('Selected:', selectedText);
        console.log('Suffix (first 50 chars):', actualSuffix.slice(0, 50));

        // Get the full text to test uniqueness
        const fullText = container.innerText;

        // Count total occurrences
        let totalOccurrences = 0;
        let idx = fullText.indexOf(selectedText);
        while (idx !== -1) {
            totalOccurrences++;
            idx = fullText.indexOf(selectedText, idx + 1);
        }

        if (totalOccurrences === 1) {
            // Even if unique, we want min 10 chars for prefix and suffix
            const minimalPrefix = actualPrefix.slice(-10) || actualPrefix;
            const minimalSuffix = actualSuffix.slice(0, 10) || actualSuffix;

            document.getElementById('searchText').value = selectedText.replace(/\n/g, '\\n');
            document.getElementById('prefixText').value = minimalPrefix.replace(/\n/g, '\\n');
            document.getElementById('suffixText').value = minimalSuffix.replace(/\n/g, '\\n');

            const storageInfo = {
                text: selectedText,
                prefix: minimalPrefix,
                suffix: minimalSuffix,
                nearestHeading: nearestHeading,
                timestamp: new Date().toISOString()
            };
            console.log('Selection data for storage:', storageInfo);

            document.getElementById('clickInfo').textContent = 'Unique selection - using minimum 10 char context';
            selection.removeAllRanges();
            highlightText();
            return;
        }

        // Find minimal prefix/suffix from the actual context (but at least 10 chars)
        let minimalPrefix = '';
        let minimalSuffix = '';
        let foundUnique = false;

        // Try with both prefix and suffix, starting at 10 chars each
        const minLength = 10;

        outerLoop: for (let totalLen = minLength * 2; totalLen <= 100; totalLen++) {
            // Try different distributions, but ensure both are at least minLength
            for (let prefixLen = minLength; prefixLen <= totalLen - minLength && prefixLen <= actualPrefix.length; prefixLen++) {
                const suffixLen = totalLen - prefixLen;
                if (suffixLen < minLength || suffixLen > actualSuffix.length) continue;

                const testPrefix = actualPrefix.slice(-prefixLen);
                const testSuffix = actualSuffix.slice(0, suffixLen);
                const pattern = testPrefix + selectedText + testSuffix;

                let count = 0;
                let idx = fullText.indexOf(pattern);
                while (idx !== -1) {
                    count++;
                    idx = fullText.indexOf(pattern, idx + 1);
                }

                if (count === 1) {
                    minimalPrefix = testPrefix;
                    minimalSuffix = testSuffix;
                    foundUnique = true;
                    console.log(`Found unique with combination: prefix="${minimalPrefix}" (${minimalPrefix.length}), suffix="${minimalSuffix}" (${minimalSuffix.length})`);
                    break outerLoop;
                }
            }
        }

        // If not found with both, try larger contexts
        if (!foundUnique) {
            // Just use 10 chars from each side if available
            minimalPrefix = actualPrefix.slice(-Math.max(minLength, actualPrefix.length));
            minimalSuffix = actualSuffix.slice(0, Math.max(minLength, actualSuffix.length));
            console.log('Using default minimum context');
        }

        // Clean up to word boundaries if it doesn't go below minimum
        if (minimalPrefix.length > minLength + 5) {
            const lastSpace = minimalPrefix.lastIndexOf(' ');
            if (lastSpace > minLength) {
                const cleanPrefix = minimalPrefix.substring(lastSpace + 1);
                if (cleanPrefix.length >= minLength) {
                    // Verify still unique
                    const pattern = cleanPrefix + selectedText + minimalSuffix;
                    if (fullText.indexOf(pattern) !== -1 && fullText.indexOf(pattern, fullText.indexOf(pattern) + 1) === -1) {
                        minimalPrefix = cleanPrefix;
                    }
                }
            }
        }

        if (minimalSuffix.length > minLength + 5) {
            const firstSpace = minimalSuffix.indexOf(' ');
            if (firstSpace > 0 && firstSpace < minimalSuffix.length - minLength) {
                const cleanSuffix = minimalSuffix.substring(0, firstSpace);
                if (cleanSuffix.length >= minLength) {
                    // Verify still unique
                    const pattern = minimalPrefix + selectedText + cleanSuffix;
                    if (fullText.indexOf(pattern) !== -1 && fullText.indexOf(pattern, fullText.indexOf(pattern) + 1) === -1) {
                        minimalSuffix = cleanSuffix;
                    }
                }
            }
        }

        // Set the values
        document.getElementById('searchText').value = selectedText.replace(/\n/g, '\\n');
        document.getElementById('prefixText').value = minimalPrefix.replace(/\n/g, '\\n');
        document.getElementById('suffixText').value = minimalSuffix.replace(/\n/g, '\\n');

        const storageInfo = {
            text: selectedText,
            prefix: minimalPrefix,
            suffix: minimalSuffix,
            nearestHeading: nearestHeading,
            timestamp: new Date().toISOString()
        };
        console.log('Selection data for storage:', storageInfo);

        document.getElementById('clickInfo').textContent =
            foundUnique ?
                `Found unique context! Prefix: "${minimalPrefix}" (${minimalPrefix.length}), Suffix: "${minimalSuffix}" (${minimalSuffix.length})` +
                (nearestHeading ? ` | Under: ${nearestHeading.tag} "${nearestHeading.text}"` : '') :
                `Using minimum context (${totalOccurrences} occurrences)` +
                (nearestHeading ? ` | Under: ${nearestHeading.tag} "${nearestHeading.text}"` : '');

        selection.removeAllRanges();
        highlightText();
    }

    // Initialize on load
    window.addEventListener('DOMContentLoaded', function() {
        const container = document.getElementById('content');
        if (container) {
            highlighter = new TextHighlighter(container);
            highlightText(); // Initial highlight
        }
    });
</script>
</body>
</html>